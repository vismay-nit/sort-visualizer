var Bubble_abt= 
`
    <div class="row">
        <ul>
            <li><strong>Bubble Sort :</strong> </li>
            <p>
                Bubble sort, sometimes referred to as sinking sort,
                is a simple sorting algorithm that repeatedly steps 
                through the list, compares adjacent elements and swaps
                them if they are in the wrong order. The pass through 
                the list is repeated until the list is sorted.<br>
            </p>
            <li><strong>Time Complexity</strong> </li>
            <ul>
                <li>Best Case :&nbsp  &nbsp &nbsp &nbsp  Ω(n)</li>
                <li>Average Case : θ(n²)</li>
                <li>Worst Case :&nbsp  &nbsp O(n²)<br><br></li>
            </ul>
            <li><strong>Space Complexity :</strong>O(1)</li>
        </ul>
    </div>
    `

var Heap_abt= 
`
<div class="row">
    <ul>
        <li><strong>Heap Sort :</strong> </li>
        <p>
            Heap sort is a comparison-based sorting
            technique based on Binary Heap data structure.
            It is similar to selection sort where we first
            find the minimum element and place the minimum
            element at the beginning. We repeat the same
            process for the remaining elements.<br>
        </p>
        <li><strong>Time Complexity</strong> </li>
        <ul>
            <li>Best Case :&nbsp  &nbsp &nbsp &nbsp  Ω(n log(n))	</li>
            <li>Average Case : θ(n log(n))</li>
            <li>Worst Case :&nbsp  &nbsp O(n log(n))	<br><br></li>
        </ul>
        <li><strong>Space Complexity :</strong>O(1)</li>
    </ul>
</div>
`

var Merge_abt= 
`
<div class="row">
    <ul>
        <li><strong>Merge Sort :</strong> </li>
        <p>
         Merge sort is one of the most efficient sorting algorithms.
         It works on the principle of Divide and Conquer. Merge sort
          repeatedly breaks down a list into several sublists until 
         each sublist consists of a single element and merging 
         sublists in a manner that results into a sorted list.<br>
        </p>
        <li><strong>Time Complexity</strong> </li>
        <ul>
            <li>Best Case :&nbsp  &nbsp &nbsp &nbsp  Ω(n log(n))	</li>
            <li>Average Case : θ(n log(n))</li>
            <li>Worst Case :&nbsp  &nbsp O(n log(n))	<br><br></li>
        </ul>
        <li><strong>Space Complexity :</strong>O(n)</li>
    </ul>
</div>
`

var Insert_abt= 
`
<div class="row">
    <ul>
        <li><strong>Insertion Sort :</strong> </li>
        <p>
        Insertion sort is a simple sorting algorithm that works
         similar to the way you sort playing cards in your hands. 
         The array is virtually split into a sorted and an unsorted 
         part. Values from the unsorted part are picked and placed 
         at the correct position in the sorted part<br>
        </p>
        <li><strong>Time Complexity</strong> </li>
        <ul>
            <li>Best Case :&nbsp  &nbsp &nbsp &nbsp  Ω(n)	</li>
            <li>Average Case : θ(n²)</li>
            <li>Worst Case :&nbsp  &nbsp O(n²)	<br><br></li>
        </ul>
        <li><strong>Space Complexity :</strong>O(1)</li>
    </ul>
</div>
`
var Select_abt= 
`
<div class="row">
    <ul>
        <li><strong>Selection Sort :</strong> </li>
        <p>
        The selection sort algorithm sorts an array by repeatedly finding the minimum 
        element (considering ascending order) from unsorted part and putting it at 
        the beginning. The algorithm maintains two subarrays in a given array.<br>
        1) The subarray which is already sorted. <br>
        2) Remaining subarray which is unsorted.<br>
        In every iteration of selection sort, the minimum element 
        (considering ascending order) from the unsorted subarray is 
        picked and moved to the sorted subarray.<br>
        </p>
        <li><strong>Time Complexity</strong> </li>
        <ul>
            <li>Best Case :&nbsp  &nbsp &nbsp &nbsp  Ω(n²)	</li>
            <li>Average Case : θ(n²)</li>
            <li>Worst Case :&nbsp  &nbsp O(n²)	<br><br></li>
        </ul>
        <li><strong>Space Complexity :</strong>O(1)</li>
    </ul>
</div>
`
var Quick_abt= 
`
<div class="row">
    <ul>
        <li><strong>Quick Sort :</strong> </li>
        <p>
        QuickSort is a Divide and Conquer algorithm. It picks an element as 
        pivot and partitions the given array around the picked pivot. 
        There are many different versions of quickSort that pick pivot in different ways.<br>
        1) Always pick first element as pivot.<br>
        2) Always pick last element as pivot.<br>
        3) Pick a random element as pivot.<br>
        4) Pick median as pivot.<br>
        The key process in quickSort is partition. Target of 
        partitions is, given an array and an element x of array 
        as pivot, put x at its correct position in sorted array 
        and put all smaller elements (smaller than x) before x, 
        and put all greater elements (greater than x) after x. 
        All this should be done in linear time.<br>
        </p>
        <li><strong>Time Complexity</strong> </li>
        <ul>
            <li>Best Case :&nbsp  &nbsp &nbsp &nbsp  Ω(n log(n))	</li>
            <li>Average Case : θ(n log(n))</li>
            <li>Worst Case :&nbsp  &nbsp O(n²)	<br><br></li>
        </ul>
        <li><strong>Space Complexity :</strong>O(log(n))</li>
    </ul>
</div>
`
